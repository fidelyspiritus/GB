# Работа с Git и GitHub

## **Git**
Git — распределённая система управления версиями для отслеживания и ведения истории изменения файлов, в вашем проекте. Чаще всего его используют для кода, но можно и для других файлов. Например, для картинок - полезно для дизайнеров.

С помощью Git-a вы можете откатить свой проект до более старой версии, сравнивать, анализировать или сливать свои изменения в репозиторий.

Основой интерфейс для работы с Git-ом является консоль/терминал.

### 1. Проверка наличия установленной программы Git
В терминале выполняется команда 

`git version`

Если **Git**  установлен, то появится сообщение с информацией о версии программы. В противном случае будет выведено сообщение об ошибке.

### 2. Установка на Linux

 Открываем терминал и вводим следующую команду.

`sudo apt install git`

### 3. Настройка

Для того, чтобы когда вы создавали commit, указывался автор, кто его создал. программе нужно представиться

Открываем терминал и вводим следующие команды.

`git config --global user.name "<ваше_имя>"`

#Теперь установим email. Принцип тот же.

`git config --global user.email "<адрес_почты>"`

### 4. Инициализация/Создание репозитория

 Для этого пройдите в папку вашего проекта.

`cd <путь_к_вашему_проекту>`

Создаем репозиторий 

`git init`

Теперь Git отслеживает изменения файлов вашего проекта. Но, так как вы только создали репозиторий в нем нет вашего кода. Для этого необходимо создать commit.

Добавим все файлы проекта в нам будующий commit

`git add` или `git add --all`

Для добавления конкретного файла
`git add <имя_файла>`

Cоздаем commit. Обязательно указываем комментарий и не забываем про кавычки
`git commit -m "<комментарий>`

Каждая точка сохранения вашего проекта носит название коммит (commit). У каждого commit-a есть hash (уникальный id) и комментарий.

Пример
git commit -m "add some information" <br/>
[master a207325] add some information <br/>
 1 file changed, 6 insertions(+) <br/>

### 5. Проверьте состояние репозитория
Используйте команду `git status`, чтобы проверить текущее состояние репозитория. <br>
`git status`<br/>
`On branch master` <br/>
`nothing to commit, working tree clean`

### 6. Получение списка произведенных изменений 
`git log` <br/>
`commit a207325a371c1f3cd62822a06f6ed1829d82aa9b (HEAD -> master)`<br/>
`Author: Lindail <...> `<br/>
`Date:   Tue Apr 25 23:36:35 2023 +0300 `<br/>

`add some information`

`commit ba174afdab9d4df384471473f44e9d286b2a075a `<br/>
`Author: Lindail <... `<br/>
`Date:   Tue Apr 25 22:43:53 2023 +0300`<br/>
`initial commit`
`
### 7. Ветвление
Предположим, вы работаете над проектом и уже имеете несколько коммитов
Отдельные проблемы или направления принято выделять в отдельные ветки.. Чтобы создать ветку и сразу переключиться на неё, можно выполнить команду `git checkout` с параметром `-b`:

    git checkout -b ignore
    Switched to a new branch "ignore"

Это то же самое что и:

     git branch ignore
     git checkout ignore
Теперь предположим, что вы зафиксировали все свои изменения и можете переключиться на ветку **master**:

    git checkout master
    Switched to branch 'master'
С этого момента ваш рабочий каталог имеет точно такой же вид, какой был перед началом работы c веткой **ignore**, и вы можете сосредоточиться на работе над исправлением. Важно запомнить: когда вы переключаете ветки, Git возвращает состояние рабочего каталога к тому виду, какой он имел в момент последнего коммита в эту ветку. Он добавляет, удаляет и изменяет файлы автоматически, чтобы состояние рабочего каталога соответствовало тому, когда был сделан последний коммит.

Вы можете выполнить слияние ветки **ignore** с веткой master для включения изменений в продукт. Это делается командой git merge:

    git checkout master
    git merge ignore
Команда `git branch` делает несколько больше, чем просто создаёт и удаляет ветки. При запуске без параметров, вы получите простой список имеющихся у вас веток:

    git branch
    * master
    ignore
Обратите внимание на символ *, стоящий перед веткой master: он указывает на ветку, на которой вы находитесь в настоящий момент
Чтобы посмотреть последний коммит на каждой из веток, выполните команду `git branch -v`
Опции `--merged` и `--no-merged` могут отфильтровать этот список для вывода только тех веток, которые слиты или ещё не слиты в текущую ветку. Чтобы посмотреть те ветки, которые вы уже слили с текущей, можете выполнить команду `git branch --merged`:
Те ветки из этого списка, перед которыми нет символа *, можно смело удалять командой `git branch -d`; наработки из этих веток уже включены в другую ветку, так что ничего не потеряется.

8. Файл .gitignore
Те ветки из этого списка, перед которыми нет символа *, можно смело удалять командой `git branch -d`; наработки из этих веток уже включены в другую ветку, так что ничего не потеряется.

файлы **.gitignore** - это гибкий и простой способ контролировать то, что попадает в ваши репозитории git.
Проще говоря, файл **.gitignore** - это текстовый файл, который сообщает git не отслеживать определенные файлы, каталоги или типы файлов.
Обычно вы получаете файл **.gitignore** одним из двух способов:
Вы сами создаете файл **.gitignore** и вручную добавляете в него правила
Вы начинаете с предварительно созданного файла **.gitignore**, который соответствует языкам и технологиям, с которыми вы работаете.
Создать файл **.gitignore** так же просто, как щелкнуть правой кнопкой мыши в проводнике и выбрать создание нового файла, а затем назвать его **.gitignore**  
Как только у вас появится файл **.gitignore**, который вам нравится, вы можете найти случаи, когда захотите настроить файл .**.gitignore** для вашего конкретного проекта.
Если вы найдете определенные файлы или папки, которые хотите добавить в файлы **.gitignore**, просто добавьте файлы по их имени или пути в нижнюю часть файла **.gitignore**.

`commit ba174afdab9d4df384471473f44e9d286b2a075a `<br/>
`Author: Lindail <... `<br/>
`Date:   Tue Apr 25 22:43:53 2023 +0300`<br/>
`initial commit`
`
### 9. Работа с удалёнными репозиториями
#### Просмотр удалённых репозиториев
Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду `git remote`. Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум **origin** — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование.

    git clone https://github.com/fidelyspiritus/SCV_Git_PR
    Cloning into 'SCV_Git_PR'...
    remote: Enumerating objects: 21, done.
    remote: Counting objects: 100% (6/6), done.
    remote: Compressing objects: 100% (2/2), done.
    remote: Total 21 (delta 5), reused 4 (delta 4), pack-reused 15
    Receiving objects: 100% (21/21), 4.66 KiB | 4.67 MiB/s, done.
    Resolving deltas: 100% (5/5), done.

Для того, чтобы добавить удалённый репозиторий и присвоить ему имя (shortname), просто выполните команду `git remote add <shortname> <url>`.

#### Получение изменений из удалённого репозитория — Fetch и Pull

Для получения данных из удалённых проектов, которые уже добавлены следует выполнить:

`$ git fetch [remote-name]`<br/>
Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта, которые вы можете просмотреть или слить в любой момент.

Когда вы клонируете репозиторий, команда `clone` автоматически добавляет этот удалённый репозиторий под именем **«origin»**. Таким образом, `git fetch origin` извлекает все наработки, отправленные на этот сервер после того, как вы его клонировали (или получили изменения с помощью fetch). Важно отметить, что команда `git fetch` забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.

Выполнение `git pull`, как правило, извлекает (**fetch**) данные с сервера, с которого вы изначально клонировали, и автоматически пытается слить (**merge**) их с кодом, над которым вы в данный момент работаете.

#### Отправка изменений в удалённый репозиторий (**Push**)
Для отправки данных в удалённый репозиторий используется команда `git push <remote-name> <branch-name>`. 

Чтобы отправить вашу ветку **main** на сервер **origin**, вы можете выполнить следующую команду для отправки ваших коммитов:

    git push origin main
Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду `push`. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду `push`, а после него выполнить команду `push` попытаетесь вы, то ваш `push` точно будет отклонён. Вам придётся сначала получить изменения и объединить их с вашими и только после этого вам будет позволено выполнить `push`.

#### Просмотр удалённого репозитория
Если хотите получить побольше информации об одном из удалённых репозиториев, вы можете использовать команду `git remote show <remote>`. Выполнив эту команду с некоторым именем, например, **origin**, вы получите следующий результат:

    git remote show origin
    * remote origin
    Fetch URL: https://github.com/fidelyspiritus/SCV_Git_PR
    Push  URL: https://github.com/fidelyspiritus/SCV_Git_PR
    HEAD branch: main
    Remote branch:
        main tracked
    Local branch configured for 'git pull':
        main merges with remote main
    Local ref configured for 'git push':
        main pushes to main (up to date)
Она выдаёт URL удалённого репозитория, а также информацию об отслеживаемых ветках. Эта команда любезно сообщает вам, что если вы, находясь на ветке **main**, выполните `git pull`, ветка **main** с удалённого сервера будет автоматически влита в вашу сразу после получения всех необходимых данных. Она также выдаёт список всех полученных ею ссылок.

#### Удаление и переименование удалённых репозиториев
Для переименования удалённого репозитория можно выполнить `git remote rename`. 
Если по какой-то причине вы хотите удалить удалённый репозиторий — вы сменили сервер или больше не используете определённое зеркало, или кто-то перестал вносить изменения — вы можете использовать `git remote rm`.

### 10. Git submodule
Часто при работе над одним проектом, возникает необходимость использовать в нём другой проект.Типичная проблема, возникающая при этом — вы хотите продолжать работать с двумя проектами по отдельности, но при этом использовать один из них в другом.<br/>
Подмодули позволяют вам сохранить один Git-репозиторий, как подкаталог другого Git-репозитория. Это даёт вам возможность клонировать в ваш проект другой репозиторий, но коммиты при этом хранить отдельно.<br/>
Для добавления нового подмодуля используйте команду `git submodule add`, указав относительный или абсолютный URL проекта, который вы хотите начать отслеживать.

    git submodule add https://github.com/fidelyspiritus/SCV_Git_PR SCV_Git_PR
    Adding existing repo at 'SCV_Git_PR' to the index
Появится новый файл **.gitmodules**. Это конфигурационный файл, в котором хранится соответствие между URL проекта и локальным подкаталогом, в который вы его выкачали:

    [submodule "SCV_Git_PR"]
	    path = SCV_Git_PR
	    url = https://github.com/fidelyspiritus/SCV_Git_PR
Если у вас несколько подмодулей, то в этом файле у вас будет несколько записей. Важно заметить, что этот файл добавлен под версионный контроль **Git** так же, как и другие ваши файлы, например, ваш файл **.gitignore**. Этот файл можно получить или отправить на сервер вместе с остальными файлами проекта. Благодаря этому другие люди, которые клонируют ваш проект, узнают откуда взять подмодули проекта.